  Grenzwert setzen/Fehlertoleranz, mismatches anzeigen
  Hinweis anzeigen, wenn Reihenfolge falsch
  Nicht nur umdrehen, sondern komplementäre Basen
Hervorheben, welche Sinn machen und welche nicht
Anhaken, welche exportiert werden sollen
Export als csv, die kann dann leicht in Excel eingelesen werden oder sonst wo
Erlaubte Lücken, bei Nina waren das die 3*12 = 36






Mögliche Anordnungen finden:



 |--------|
           |-----|
                  |----|

 |========||=====||====|

Das erste nehmen
Ist die Position des nächsten Elements > als Position des aktuellen Elements?
  1: Hänge das nächste an


 |--------|
       |-----|
                  |----|

 |========|       |====|
       |=====|    |====|

Das erste nehmen
Ist die Position des nächsten Elements > als Position des aktuellen Elements?
  1: Hänge das nächste an
  0: Merke & überspringe dieses Element, dann betrachte das nächste
Nimm das erste übersprungene Element
Ist die Position des nächsten Elements > als Position des aktuellen Elements?
  1: Hänge das nächste an
  0: Überspringe dieses Element, dann betrachte das nächste


 |--------|
       |-----|
            |---|
                  |----|

 |========| |===| |====|
       |=====|    |====|

Das erste nehmen
Ist die Position des nächsten Elements > als Position des aktuellen Elements?
  1: Hänge das nächste an
  0: Merke & überspringe dieses Element, dann betrachte das nächste
Nimm das erste übersprungene Element
Ist die Position des nächsten Elements > als Position des aktuellen Elements?
  1: Hänge das nächste an
  0: Überspringe dieses Element, dann betrachte das nächste



		var orders = [];
		while (starters.length > 0) {
			var rest = alignments.slice(0); // klonieren
			var order = [starters[0]];
			while (rest.length > 0) {
				if (rest[0].position > wenn das nächste passt
					order = [rest.pop()];
				else
					starters.push(rest.pop());
			}
			orders.push(order);
		}



|-----|  |--|
 |--||---|

alle möglichen ohne rücksicht auf position machen, dann immer rauskicken wenn eins nich zum vorherigen passt


                             
      |--------|
         |----|
          |------|
           |----|
            |-----|
              |----|
               |-|
                 |---|
                  |-|
                   |--|
                    |----|
                       |----|
                     
25           |=|  |====|     der hier auch
24           |=| |==||====|  der hier auch
23           |=||=|  |====|  der hier überlagert sich zwar mit dem ersten starter, aber nicht mit dem 2., und ist somit ein teilproblem!
22 20         |====|   |====|
21 19         |====||====|   
20 18       |=====| |====|
19 17       |=====||==||====|
18 16      |====|   |====|
17 15      |====|  |==||====|
16 14      |====| |=|  |====|
15 13      |====||===| |====|
14 12     |======|  |====|
13 11     |======| |==||====|
12 10     |======||=|  |====|
11 09    |====||=|  |====|
10 09    |====|    |==||====|  das hier auch
09 08    |====|   |=|  |====|  das ist ein teilproblem, darf nicht gefunden werden
08 08    |====|  |===| |====|
07 07    |====||=|  |====|
06 06    |====||=| |==||====|
05 05    |====||=||=|  |====|
04 04 |========|    |====|
03 03 |========|   |==||====|
02 02 |========|  |=|  |====|
01 01 |========| |===| |====|


Wenn ein Fragment A zu einem Fragment B verbunden ist, und beide zu Fragment C verbunden sind, dann lösche die Verbindung von A nach C, weil BC und AC Teil von ABC sind. So kann von A nach B und dann von B nach C gegangen werden.

Zu jedem Fragment die möglichen, einzelnen Nachfolger bestimmen
Für jedes Element, für das gilt: Menge der Fragmente, deren Ende < Start dieses Fragments ist, ist leer
  Für jeden Nachfolger
    Lösche die Nachfolger vom Elternelement, die auch Nachfolger dieses Nachfolgers sind